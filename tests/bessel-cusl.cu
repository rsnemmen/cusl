/* 
  Testing the CUSL Bessel implementations
*/

#include <stdio.h> 
#include <stdlib.h> 
#include "cheb_eval.cuh"
#include "poly.cuh"
#include "bessel.cuh"

#define TPB 64  

#define N 100
#define x0 0.1
#define x1 5.
#define filename "bessel-cuda-cusl.dat"
/* The corresponding GSL values are located in column 2 of the file
   bessel-gsl.dat generated by bessel-gsl.c
*/


__global__ void bessel(double *x, double *K0, double *i0, double *i1, int n){ 
	int id = blockIdx.x*blockDim.x + threadIdx.x; 

	if (id>=n) return;

	K0[id] =cu_sf_bessel_K0_scaled_e(x[id]);
	//i0[id] =cyl_bessel_i0(x[id]);
	//i1[id] =cyl_bessel_i1(x[id]);
}



int main(int argc, char *argv[]){
	int i;
	double *x, *K0, *i0, *i1;

	// Allocate Unified Memory â€“ accessible from CPU or GPU
	cudaMallocManaged(&x, N*sizeof(double));
	cudaMallocManaged(&K0, N*sizeof(double));	
	cudaMallocManaged(&i0, N*sizeof(double));	
	cudaMallocManaged(&i1, N*sizeof(double));	

	for (i=0; i<N; i++) {
		// generate array of x-values
		x[i]=x0+i*(x1-x0)/(N-1);
	}	

	// kernel launch
    printf("Computing Bessel function on the GPU\n");
	bessel<<<(N+TPB-1)/TPB, TPB>>>(x, K0, i0, i1, N); 
	
	// Wait for GPU to finish before accessing on host
	cudaDeviceSynchronize();

	// write file
	printf("Saving file %s\n", filename);
    FILE *f = fopen(filename, "w");
    if (f == NULL) {
        printf("Error opening file!\n");
        exit(1);
    }

    fprintf(f, "# x K0");
    for (i=0; i<N; i++) {
        fprintf(f, "%f %f %f %f \n", x[i], K0[i], i0[i], i1[i]);
    }

    // clean up
    fclose(f);
    cudaFree(x);
    cudaFree(K0);
	cudaFree(i0);
	cudaFree(i1); 

	return 0; 
}