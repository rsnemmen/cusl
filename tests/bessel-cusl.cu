/* 
  Testing the CUSL Bessel implementations
*/

#include <stdio.h> 
#include <stdlib.h>
#include <curand_kernel.h>
#include "cusl_math.h" 
#include "cheb_eval.cuh"
#include "poly.cuh"
#include "psi.cuh"
#include "gamma.cuh"
#include "bessel.cuh"

#define TPB 64  

#define N 100
#define x0 0.1
#define x1 5.
#define filename "bessel-cuda-cusl.dat"
/* The corresponding GSL values are located in column 2 of the file
   bessel-gsl.dat generated by bessel-gsl.c
*/


__global__ void bessel(double *x, double *K0, double *K1, double *Kn_small, double *Kn, int n){ 
	int id = blockIdx.x*blockDim.x + threadIdx.x; 

	if (id>=n) return;

	K0[id] =cu_sf_bessel_K0_scaled_e(x[id]);
	K1[id] =cu_sf_bessel_K1_scaled_e(x[id]);
	Kn_small[id] =bessel_Kn_scaled_small_x(2,x[id]);
	Kn[id] =cu_sf_bessel_Kn(2,x[id]);
}



int main(int argc, char *argv[]){
	int i;
	double *x, *K0, *K1, *Kn_small, *Kn;

	// Allocate Unified Memory â€“ accessible from CPU or GPU
	cudaMallocManaged(&x, N*sizeof(double));
	cudaMallocManaged(&K0, N*sizeof(double));	
	cudaMallocManaged(&K1, N*sizeof(double));	
	cudaMallocManaged(&Kn_small, N*sizeof(double));	
	cudaMallocManaged(&Kn, N*sizeof(double));	

	for (i=0; i<N; i++) {
		// generate array of x-values
		x[i]=x0+i*(x1-x0)/(N-1);
	}	

	// kernel launch
    printf("Computing Bessel function on the GPU\n");
	bessel<<<(N+TPB-1)/TPB, TPB>>>(x, K0, K1, Kn_small, Kn, N); 
	
	// Wait for GPU to finish before accessing on host
	cudaDeviceSynchronize();

	// write file
	printf("Saving file %s\n", filename);
    FILE *f = fopen(filename, "w");
    if (f == NULL) {
        printf("Error opening file!\n");
        exit(1);
    }

    fprintf(f, "# x K0");
    for (i=0; i<N; i++) {
        fprintf(f, "%f %f %f %f %f \n", x[i], K0[i], K1[i], Kn_small[i], Kn[i]);
    }

    // clean up
    fclose(f);
    cudaFree(x);
    cudaFree(K0);
	cudaFree(K1);
	cudaFree(Kn_small); 
	cudaFree(Kn);

	return 0; 
}